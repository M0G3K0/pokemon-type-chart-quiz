/**
 * Token-to-Types Generator
 *
 * @what  ãƒˆãƒ¼ã‚¯ãƒ³JSONã‹ã‚‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®types.tsã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹
 * @why   ãƒˆãƒ¼ã‚¯ãƒ³å¤‰æ›´æ™‚ã«types.tsã‚’æ‰‹å‹•æ›´æ–°ã™ã‚‹å¿…è¦ã‚’ãªãã—ã€Single Source of Truthã‚’å®Ÿç¾ã™ã‚‹
 * @failure  types.tsã¨ãƒˆãƒ¼ã‚¯ãƒ³JSONã®ä¸æ•´åˆãŒãªããªã‚‹
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.resolve(__dirname, '..');

// ============================================================================
// Configuration: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã”ã¨ã®ãƒãƒƒãƒ”ãƒ³ã‚°å®šç¾©
// ============================================================================

/**
 * @typedef {Object} VariantConfig
 * @property {string} tokenPath - ãƒˆãƒ¼ã‚¯ãƒ³JSONå†…ã®ã‚­ãƒ¼ãƒ‘ã‚¹ï¼ˆãƒ‰ãƒƒãƒˆåŒºåˆ‡ã‚Šï¼‰
 * @property {string} typeName - ç”Ÿæˆã™ã‚‹TypeScriptå‹å
 * @property {string} constName - ç”Ÿæˆã™ã‚‹constå
 */

/**
 * @typedef {Object} ComponentConfig
 * @property {string} tokenFile - ãƒˆãƒ¼ã‚¯ãƒ³JSONãƒ•ã‚¡ã‚¤ãƒ«å
 * @property {string} outputFile - å‡ºåŠ›å…ˆã®types.tsãƒ‘ã‚¹ï¼ˆsrcã‹ã‚‰ã®ç›¸å¯¾ï¼‰
 * @property {string} rootKey - ãƒˆãƒ¼ã‚¯ãƒ³JSONã®ãƒ«ãƒ¼ãƒˆã‚­ãƒ¼
 * @property {VariantConfig[]} variants - ãƒãƒªã‚¢ãƒ³ãƒˆå®šç¾©
 * @property {string[]} [additionalImports] - è¿½åŠ ã®importæ–‡
 * @property {string[]} [additionalExports] - è¿½åŠ ã®exportæ–‡ï¼ˆæ‰‹å‹•ç®¡ç†ã®å‹ãªã©ï¼‰
 */

/** @type {ComponentConfig[]} */
const COMPONENT_CONFIGS = [
    {
        tokenFile: 'chip.json',
        outputFile: 'src/app/ui/pt-chip/pt-chip.types.ts',
        rootKey: 'chip',
        variants: [
            {
                tokenPath: 'padding.x',
                typeName: 'ChipSize',
                constName: 'CHIP_SIZES',
            },
            {
                tokenPath: 'radius',
                typeName: 'ChipRounded',
                constName: 'CHIP_ROUNDED',
            },
        ],
    },
    {
        tokenFile: 'icon.json',
        outputFile: 'src/app/ui/pt-icon/pt-icon.types.ts',
        rootKey: 'icon',
        variants: [
            {
                tokenPath: 'size',
                typeName: 'IconSize',
                constName: 'ICON_SIZES',
            },
        ],
        additionalImports: ["import { PokemonType } from '@domain/type-chart';"],
        additionalExports: ["export type IconColor = PokemonType | 'inverse';"],
    },
];

// ============================================================================
// Generator Logic
// ============================================================================

/**
 * ãƒã‚¹ãƒˆã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚­ãƒ¼ãƒ‘ã‚¹ã§ã‚¢ã‚¯ã‚»ã‚¹
 */
function getByPath(obj, dotPath) {
    return dotPath.split('.').reduce((current, key) => {
        if (current && typeof current === 'object' && key in current) {
            return current[key];
        }
        return undefined;
    }, obj);
}

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒãƒªã‚¢ãƒ³ãƒˆã‚­ãƒ¼ä¸€è¦§ã‚’æŠ½å‡º
 * $descriptionãªã©ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ¼ã¯é™¤å¤–
 */
function extractVariantKeys(tokenObj) {
    if (!tokenObj || typeof tokenObj !== 'object') {
        return [];
    }
    return Object.keys(tokenObj).filter((key) => !key.startsWith('$'));
}

/**
 * ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®types.tsã‚’ç”Ÿæˆ
 */
function generateTypesFile(config) {
    const tokenFilePath = path.join(
        PROJECT_ROOT,
        'design-tokens/tier3-component',
        config.tokenFile
    );

    if (!fs.existsSync(tokenFilePath)) {
        console.error(`  âŒ Token file not found: ${tokenFilePath}`);
        return null;
    }

    const tokenData = JSON.parse(fs.readFileSync(tokenFilePath, 'utf8'));
    const rootObj = tokenData[config.rootKey];

    if (!rootObj) {
        console.error(
            `  âŒ Root key "${config.rootKey}" not found in ${config.tokenFile}`
        );
        return null;
    }

    const lines = [];

    // Header
    lines.push('/**');
    lines.push(
        ` * ${config.rootKey.charAt(0).toUpperCase() + config.rootKey.slice(1)} component variant types`
    );
    lines.push(' * @generated by scripts/generate-types-from-tokens.mjs');
    lines.push(' * Do not edit manually - run `npm run tokens:build` to regenerate');
    lines.push(' */');

    // Additional imports
    if (config.additionalImports) {
        lines.push('');
        config.additionalImports.forEach((imp) => lines.push(imp));
    }

    // Generate variants
    for (const variant of config.variants) {
        const tokenObj = getByPath(rootObj, variant.tokenPath);
        const keys = extractVariantKeys(tokenObj);

        if (keys.length === 0) {
            console.warn(
                `  âš ï¸  No keys found at ${config.rootKey}.${variant.tokenPath}`
            );
            continue;
        }

        const unionType = keys.map((k) => `'${k}'`).join(' | ');
        const arrayValues = keys.map((k) => `'${k}'`).join(', ');

        lines.push('');
        lines.push(`export type ${variant.typeName} = ${unionType};`);
        lines.push('');
        lines.push(`/** Available ${config.rootKey} ${variant.tokenPath.split('.').pop()} variants */`);
        lines.push(
            `export const ${variant.constName}: ${variant.typeName}[] = [${arrayValues}];`
        );
    }

    // Additional exports
    if (config.additionalExports) {
        lines.push('');
        config.additionalExports.forEach((exp) => lines.push(exp));
    }

    lines.push('');

    return lines.join('\n');
}

// ============================================================================
// Main
// ============================================================================

console.log('\nğŸ”„ Generating types from tokens...\n');

let hasError = false;

for (const config of COMPONENT_CONFIGS) {
    const content = generateTypesFile(config);

    if (content === null) {
        hasError = true;
        continue;
    }

    const outputPath = path.join(PROJECT_ROOT, config.outputFile);

    // æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã¨æ¯”è¼ƒã—ã¦å¤‰æ›´ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    let changed = true;
    if (fs.existsSync(outputPath)) {
        const existing = fs.readFileSync(outputPath, 'utf8');
        // æ”¹è¡Œã‚³ãƒ¼ãƒ‰ã‚’çµ±ä¸€ã—ã¦æ¯”è¼ƒ
        changed = existing.replace(/\r\n/g, '\n') !== content.replace(/\r\n/g, '\n');
    }

    if (changed) {
        fs.writeFileSync(outputPath, content, 'utf8');
        console.log(`  âœ… Updated: ${config.outputFile}`);
    } else {
        console.log(`  â­ï¸  No changes: ${config.outputFile}`);
    }
}

if (hasError) {
    console.error('\nâŒ Some types generation failed.');
    process.exit(1);
} else {
    console.log('\nâœ… Types generation completed.');
}
